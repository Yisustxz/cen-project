\documentclass[12pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{titlesec}

\geometry{letterpaper, margin=2.5cm}

\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{\textbf{Implementación de un Sistema Multijugador para Space Shooter}}
\author{Nombre del Estudiante \\ Universidad}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introducción}

Space Shooter es un juego de tipo arcade desarrollado en Python utilizando la biblioteca Pygame, donde el jugador controla una nave espacial y debe esquivar y destruir meteoritos que caen desde la parte superior de la pantalla. Originalmente desarrollado como un juego para un solo jugador, este proyecto busca ampliar sus características para permitir la modalidad multijugador.

El objetivo principal es transformar la experiencia de juego individual en una experiencia multijugador cooperativa, donde múltiples jugadores puedan unirse a una misma partida para enfrentar juntos la amenaza de los meteoritos. Para lograr esto, se implementará una arquitectura cliente-servidor, donde un servidor desarrollado en Go gestionará la lógica del juego y la comunicación entre los clientes mediante gRPC.

Este informe detalla el proceso de análisis, diseño e implementación del sistema multijugador para Space Shooter, abordando los desafíos técnicos y las soluciones propuestas.

\section{Análisis del Problema}

\subsection{Estado Actual del Juego}

El juego Space Shooter en su versión original es una aplicación monolítica para un solo jugador que ejecuta toda la lógica del juego en un mismo proceso. El juego cuenta con los siguientes componentes principales:

\begin{itemize}
    \item \textbf{Motor del juego}: Gestiona el bucle principal, la detección de colisiones y el renderizado.
    \item \textbf{Gestor de objetos}: Administra la creación, actualización y destrucción de entidades del juego.
    \item \textbf{Sistema de tiempo delta}: Asegura que el movimiento de los objetos sea consistente independientemente de la velocidad de cuadros.
    \item \textbf{Entidades}: Clases que representan al jugador, meteoritos, misiles y otros elementos del juego.
    \item \textbf{Gestor de meteoritos}: Controla la generación y comportamiento de los meteoritos.
\end{itemize}

\subsection{Desafíos de la Implementación Multijugador}

La transformación del juego en un sistema multijugador implica afrontar varios desafíos técnicos:

\begin{enumerate}
    \item \textbf{Sincronización de estado}: Mantener coherente el estado del juego entre todos los clientes conectados.
    \item \textbf{Latencia de red}: Gestionar los retrasos en la comunicación para mantener una experiencia fluida.
    \item \textbf{Autoridad del servidor}: Establecer el servidor como fuente de verdad para prevenir trampas o inconsistencias.
    \item \textbf{Escalabilidad}: Diseñar el sistema para admitir múltiples jugadores simultáneos.
    \item \textbf{Integración}: Adaptar el código existente para trabajar con la nueva arquitectura cliente-servidor.
    \item \textbf{Interoperabilidad}: Garantizar la comunicación eficiente entre el cliente Python y el servidor Go.
\end{enumerate}

\subsection{Requisitos del Sistema Multijugador}

Para implementar un sistema multijugador funcional, se han establecido los siguientes requisitos:

\begin{itemize}
    \item Permitir que múltiples jugadores se conecten a una misma sala de juego.
    \item Sincronizar la generación y movimiento de meteoritos entre todos los clientes.
    \item Transmitir las acciones de cada jugador a los demás participantes.
    \item Gestionar correctamente las colisiones y puntuaciones.
    \item Proporcionar un mecanismo para unirse a partidas en curso.
    \item Mantener la fluidez del juego minimizando el impacto de la latencia.
\end{itemize}

\section{Diseño de la Solución}

\subsection{Arquitectura Cliente-Servidor}

Para abordar los desafíos identificados, se ha optado por una arquitectura cliente-servidor:

\begin{itemize}
    \item \textbf{Cliente (Python)}: Mantiene la interfaz gráfica, recibe eventos del servidor y envía acciones del jugador.
    \item \textbf{Servidor (Go)}: Gestiona la lógica del juego, sincroniza el estado entre clientes y actúa como autoridad final.
    \item \textbf{Comunicación (gRPC)}: Permite una comunicación eficiente y tipada entre cliente y servidor.
\end{itemize}

Esta separación permite centralizar la lógica crítica en el servidor, reduciendo la posibilidad de inconsistencias y facilitando la sincronización.

\subsection{Estructura del Proyecto}

La estructura del proyecto se reorganizará para acomodar los nuevos componentes:

\begin{lstlisting}[language=bash, caption=Estructura de carpetas del proyecto]
python-space-shooter/
├── legacy/                    # Código anterior
├── config.json                # Configuración general
├── go-server/                 # Nuevo servidor Go
│   ├── main.go                # Punto de entrada
│   ├── proto/                 # Definiciones gRPC
│   ├── motor/                 # Motor del juego
│   ├── utils/                 # Utilidades
│   └── space_shooter/         # Lógica específica
├── python-game/               # Cliente Python
    └── src/
        ├── menu/              # Menú del juego
        ├── motor/             # Motor del juego
        └── space_shooter/     # Lógica específica
            ├── networking/    # Cliente gRPC
\end{lstlisting}

\subsection{Protocolo de Comunicación}

La comunicación entre cliente y servidor se realizará mediante gRPC, utilizando Protocol Buffers para definir los mensajes. Se han definido los siguientes tipos de comunicación:

\begin{itemize}
    \item \textbf{Unirse a partida}: El cliente solicita unirse y recibe un stream de eventos.
    \item \textbf{Envío de acciones}: El cliente envía las acciones del jugador al servidor.
    \item \textbf{Eventos del juego}: El servidor notifica a los clientes sobre meteoritos, misiles, colisiones, etc.
    \item \textbf{Estado del juego}: Sincronización completa del estado para nuevos jugadores.
\end{itemize}

\subsection{Flujos de Comunicación}

Se han diseñado flujos específicos para las operaciones críticas:

\subsubsection{Flujo de Unión a Partida}
\begin{enumerate}
    \item Cliente solicita unirse.
    \item Servidor crea una sala si no existe o añade al jugador a una existente.
    \item Servidor envía el estado actual al nuevo jugador.
    \item Servidor notifica a todos los jugadores sobre el nuevo participante.
\end{enumerate}

\subsubsection{Flujo de Generación de Meteoritos}
\begin{enumerate}
    \item Servidor determina que es momento de crear un meteorito.
    \item Servidor genera propiedades aleatorias y lo crea en su motor.
    \item Servidor envía evento a todos los clientes con los datos del meteorito.
    \item Clientes crean meteoritos idénticos localmente.
\end{enumerate}

\subsubsection{Flujo de Control del Jugador}
\begin{enumerate}
    \item Cliente detecta pulsación de tecla y envía acción al servidor.
    \item Servidor actualiza la posición del jugador.
    \item Servidor notifica a todos los clientes sobre el movimiento.
    \item Clientes actualizan la posición del jugador correspondiente.
\end{enumerate}

\section{Implementación}

\subsection{Servidor Go}

El servidor Go se ha estructurado en módulos que reflejan la organización del cliente Python original, facilitando la reimplementación de la lógica del juego:

\begin{lstlisting}[language=go, caption=Ejemplo de implementación del DeltaTime en Go]
package utils

import (
    "sync"
    "time"
)

// DeltaTime mantiene el tiempo entre frames
type DeltaTime struct {
    lastTime  time.Time
    delta     float64
    maxDelta  float64
    baseFPS   float64
    mutex     sync.Mutex
}

// Update actualiza el delta time
func (dt *DeltaTime) Update() {
    dt.mutex.Lock()
    defer dt.mutex.Unlock()
    
    currentTime := time.Now()
    elapsed := currentTime.Sub(dt.lastTime).Seconds()
    
    // Limitar el delta máximo
    if elapsed > dt.maxDelta {
        elapsed = dt.maxDelta
    }
    
    dt.delta = elapsed
    dt.lastTime = currentTime
}
\end{lstlisting}

\subsection{Sistema de Networking en Python}

Se ha implementado un gestor de networking en Python para comunicarse con el servidor Go:

\begin{lstlisting}[language=python, caption=Ejemplo del NetworkingManager en Python]
class NetworkingManager:
    def __init__(self, game):
        self.game = game
        self.channel = None
        self.player_id = None
        self.connected = False
        
    def connect(self, server_address, player_name):
        try:
            # Crear canal gRPC
            self.channel = grpc.insecure_channel(server_address)
            self.stub = spaceshooter_pb2_grpc.GameServiceStub(self.channel)
            
            # Iniciar stream de eventos
            join_request = spaceshooter_pb2.JoinRequest(player_name=player_name)
            self.event_stream = self.stub.JoinGame(join_request)
            
            # Iniciar hilo para procesar eventos
            self.event_thread = threading.Thread(target=self._process_events)
            self.event_thread.daemon = True
            self.event_thread.start()
            
            return True
        except Exception as e:
            print(f"Error al conectar: {e}")
            return False
\end{lstlisting}

\subsection{Modificaciones al Cliente Python}

Se han realizado las siguientes modificaciones al cliente Python:

\begin{itemize}
    \item Simplificación del menú para mostrar solo la opción "Unirse a partida".
    \item Adaptación del MeteorManager para recibir datos de meteoritos desde el servidor.
    \item Modificación del Player para enviar acciones al servidor.
    \item Implementación de la sincronización de estado entre jugadores.
\end{itemize}

\subsection{Gestión de Salas de Juego}

El servidor es capaz de gestionar salas de juego, creando una nueva sala cuando un jugador intenta unirse y no hay ninguna sala activa, o añadiendo al jugador a una sala existente. Esto permite que múltiples jugadores se conecten a la misma partida.

\section{Pruebas – Ejecución}

[Aquí se colocarán capturas de pantalla y resultados de las pruebas realizadas]

Las pruebas del sistema multijugador se dividirán en varias etapas:

\begin{enumerate}
    \item \textbf{Pruebas unitarias}: Verificar el correcto funcionamiento de componentes individuales.
    \item \textbf{Pruebas de integración}: Comprobar la comunicación entre cliente y servidor.
    \item \textbf{Pruebas de carga}: Evaluar el comportamiento del sistema con múltiples clientes.
    \item \textbf{Pruebas de latencia}: Analizar el impacto de la latencia en la jugabilidad.
\end{enumerate}

\section{Conclusiones}

La implementación de un sistema multijugador para Space Shooter representa un avance significativo en la evolución del juego, transformándolo de una experiencia individual a una colaborativa. Este proyecto ha demostrado los siguientes puntos clave:

\begin{itemize}
    \item La arquitectura cliente-servidor es efectiva para sincronizar el estado del juego entre múltiples jugadores.
    \item gRPC proporciona una comunicación eficiente y tipada, ideal para juegos en tiempo real.
    \item La separación de la lógica del juego y la presentación facilita la implementación multijugador.
    \item Go es una elección adecuada para el servidor debido a su rendimiento y soporte para concurrencia.
\end{itemize}

Futuras mejoras podrían incluir:

\begin{itemize}
    \item Implementación de predicción de movimiento para reducir el impacto de la latencia.
    \item Soporte para múltiples salas de juego simultáneas.
    \item Tablas de clasificación y estadísticas de jugadores.
    \item Modos de juego competitivos adicionales.
\end{itemize}

\section{Bibliografía}

[Referencias bibliográficas en formato APA]

\begin{enumerate}
    \item Pygame Community. (2023). Pygame Documentation. \url{https://www.pygame.org/docs/}
    \item The Go Authors. (2023). The Go Programming Language. \url{https://golang.org/doc/}
    \item gRPC Authors. (2023). gRPC Documentation. \url{https://grpc.io/docs/}
    \item Protocol Buffers. (2023). Protocol Buffers Developer Guide. \url{https://developers.google.com/protocol-buffers/docs/overview}
\end{enumerate}

\end{document} 